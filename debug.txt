ðŸ”§ Project: Dynamic Memory Debugger in C++
âœ… What It Does:
Tracks all dynamic memory allocations and deallocations (new, delete).

Detects:

Memory leaks (unfreed memory before program ends)

Double deletes

Invalid frees

Reports issues at the end of program execution.

ðŸ“š Concepts Used:
1. Operator Overloading
Overloaded operator new and operator delete to intercept memory allocation.

Tracked extra info like file and line using a macro.

2. Preprocessor Macros
cpp
Copy
Edit
#define new new(__FILE__, __LINE__)
Replaces all new calls with a version that includes file and line info â€” helps track source of allocation.

3. Static Class & Singleton Pattern
Used a static method and static map in MemoryDebugger class.

Ensures one global store of allocations across the program.

4. Hash Map (std::unordered_map)
Maps pointer addresses to metadata (size, file, line).

Allows fast lookup for delete/validation.

5. Memory Functions
Uses malloc() and free() internally for allocation (instead of new) to avoid recursion.

6. Leak Detection
reportLeaks() called at the end to show unfreed pointers.

ðŸ§ª Sample Features:
Feature	Explanation
Track Allocation	Logs pointer, size, file, line
Detect Leak	If pointer is not freed, itâ€™s reported
Double Delete	Second delete on same pointer prints error
Invalid Free	Deleting untracked pointer gives warning

ðŸ§  Possible Interview Questions & Answers:
ðŸ”¹ Q: Why did you override operator new instead of using malloc?
A: Because most modern C++ code uses new/delete. Overriding these helps catch real-world leaks in user-defined classes.

ðŸ”¹ Q: How do you avoid infinite recursion in your new/delete?
A: I use malloc() and free() internally instead of new/delete inside the custom operators.

ðŸ”¹ Q: Why use macros like #define new new(__FILE__, __LINE__)?
A: This passes the file and line number automatically to track where the allocation happened â€” helpful for debugging.

ðŸ”¹ Q: Can this handle new[] and delete[]?
A: Not in the basic version. But yes, we can overload operator new[] and operator delete[] the same way.

ðŸ”¹ Q: What happens if you don't free memory?
A: It stays in the map and gets reported as a memory leak in reportLeaks().

ðŸ”¹ Q: Why is it implemented in a .h file?
A: So that #define new and operator overrides affect all translation units (.cpp files). Also makes it header-only and portable.

ðŸ”¹ Q: How is this different from Valgrind or ASan?
A: This is a simple custom solution for learning and small programs. Valgrind and AddressSanitizer are much more powerful, handle all memory and threading issues, and are used in production.